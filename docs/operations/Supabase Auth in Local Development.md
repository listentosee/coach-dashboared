# Critical Issues and Battle-Tested Solutions

**Supabase authentication in local development environments fails primarily due to configuration mismatches, header handling differences, and auth context propagation issues between production and local setups.** [GitHub](https://github.com/supabase/supabase/issues/28008)[GitHub](https://github.com/supabase/supabase/issues/7627) The most critical problems stem from using wrong API ports (54323 instead of 54321), [GitHub](https://github.com/orgs/supabase/discussions/26718) missing OAuth redirect_uri configurations requiring full container restarts, [egghead.io](https://egghead.io/lessons/github-implement-authentication-for-supabase-with-oauth-and-github) and server-side code incorrectly trusting getSession() instead of getUser() for validation. [GitHub](https://github.com/orgs/supabase/discussions/22470)[Catjam](https://catjam.fi/articles/supabase-gen-access-token) Based on 2024-2025 sources, teams consistently resolve these issues through specific config.toml patterns, proper middleware implementations, and strict separation of browser, server, and admin Supabase clients.

**Why this matters:** Local development auth failures create a false sense of security, with code working locally but breaking in production due to cookie handling differences, RLS policy enforcement discrepancies, and JWT claim variations. These issues cost development teams days of debugging and can lead to security vulnerabilities if not properly addressed. The transition to PKCE flow requirements for SSR frameworks and the introduction of new publishable keys in 2024 have fundamentally changed auth implementation patterns. [Restack +3](https://www.restack.io/docs/supabase-knowledge-supabase-vs-vercel-edge-functions)

**Background:** Supabase local development runs entirely in Docker containers with services on specific ports. [MakerKit +4](https://makerkit.dev/docs/next-supabase/running-the-application) The auth service (GoTrue) operates differently from cloud deployments, requiring explicit configuration in config.toml files that cloud users manage through dashboard UIs. [Restack +3](https://www.restack.io/docs/supabase-knowledge-supabase-edge-functions-hosting) Framework-specific SSR requirements from Next.js, SvelteKit, and others add complexity through cookie-based session management that behaves differently across HTTP (local) and HTTPS (production) environments. [supabase +3](https://supabase.com/docs/guides/auth/server-side/nextjs) The CLI's restart requirements for configuration changes create a common source of frustration where developers modify settings but fail to see changes applied. [GitHub](https://github.com/orgs/supabase/discussions/2818)[Supabase](https://supabase.com/docs/guides/local-development/cli/config)

**Key insight:** Nearly all local auth issues trace back to three root causes: port confusion between Studio (54323) and API (54321), incomplete restarts after config changes, and mixing client types (browser vs server vs admin) that have fundamentally different session handling behaviors.

## Problems with Supabase auth in local development

Local Supabase auth development suffers from distinct behavioral differences compared to production environments. [Supabase](https://supabase.com/docs/guides/self-hosting/docker) The most pervasive issue involves **port misidentification**, where developers accidentally configure clients to use port 54323 (Studio UI) instead of 54321 (API Gateway). This generates CORS errors with missing Access-Control-Allow-Origin headers, though the underlying problem has nothing to do with CORS configuration. Supabase local development exposes multiple services on different ports: API on 54321, Database on 54322, Studio on 54323, and Inbucket email testing on 54324. [Restack +5](https://www.restack.io/docs/supabase-knowledge-supabase-edge-functions-hosting) Using the wrong port is the number one cause of "CORS" errors in local development.

**AuthSessionMissingError** represents the single most reported error in local development, typically caused by PKCE flow environment mismatches or hostname inconsistencies between localhost and 127.0.0.1. [GitHub](https://github.com/orgs/supabase/discussions/25835) When authentication flows start in one environment (like a mobile app or different browser) and attempt to complete in local development, PKCE security measures reject the session. [GitHub](https://github.com/orgs/supabase/discussions/26791)[github](https://github.com/orgs/supabase/discussions/26791) The error also occurs when developers set site_url to "127.0.0.1" in config.toml but access their frontend via "localhost", creating cookie domain mismatches that prevent session recognition.

OAuth provider configuration requires explicit redirect_uri parameters in config.toml that cloud users never see. [Alberto Sadde](https://www.albertosadde.com/blog/local-auth-with-subapase/)[albertosadde](https://www.albertosadde.com/blog/local-auth-with-subapase/) Without the redirect_uri line pointing to "[http://localhost:54321/auth/v1/callback](http://localhost:54321/auth/v1/callback)", OAuth flows complete at the provider level but fail to establish Supabase sessions. [Alberto Sadde +2](https://www.albertosadde.com/blog/local-auth-with-subapase/) Developers must add this same redirect URI to their OAuth provider dashboards (Google Cloud Console, GitHub Apps, etc.) [albertosadde +3](https://www.albertosadde.com/blog/local-auth-with-subapase/) and critically, OAuth configuration changes require a complete stop and start of the Supabase stack—not just a database reset. [Supabase +2](https://supabase.com/docs/guides/cli/local-development) The command sequence **supabase stop && supabase start** becomes essential after any config.toml modification. [GitHub](https://github.com/orgs/supabase/discussions/2818)

Token refresh failures in local development often stem from middleware not properly handling cookie updates. [GitHub](https://github.com/orgs/supabase/discussions/26718) Next.js applications specifically suffer from route prefetching issues where Link components trigger server requests before browsers process authentication tokens from URL fragments. Server-side requests arrive without cookies, rendering unauthenticated content that the browser then caches. [Vercel](https://docs-fe4unoip4-supabase.vercel.app/docs/guides/auth/server-side-rendering)[Supabase](https://supabase.com/docs/guides/auth/server-side/advanced-guide) This creates confusing scenarios where users appear logged in on some pages but not others depending on navigation patterns.

Environment variable loading presents framework-specific challenges. React applications require REACT_APP_ prefixes, Next.js needs NEXT_PUBLIC_ prefixes, and Expo demands EXPO_PUBLIC_ prefixes for client-accessible variables. [Stack Overflow](https://stackoverflow.com/questions/75048097/cannot-access-env-variables-react-supabase) Local development also requires these variables in plain .env files without quotes around values, though developers commonly add quotes out of habit from other contexts. [egghead.io](https://egghead.io/lessons/github-implement-authentication-for-supabase-with-oauth-and-github) Edge Functions running in Docker containers cannot use "localhost" URLs and must reference "host.docker.internal" to reach services on the host machine, creating another environment-specific configuration requirement. [GitHub](https://github.com/supabase/cli/issues/4139)

The **signUp() behavioral difference** between local and production represents a known bug where local development returns explicit error messages for existing users while production correctly obfuscates this information for security. This affects user registration testing and requires developers to understand that local behavior intentionally differs from production to facilitate debugging.

Custom auth hooks work in production but fail silently in local development without proper configuration. [GitHub](https://github.com/orgs/supabase/discussions/22600) Hooks must use the "pg-functions://postgres/public/function_name" URI pattern rather than HTTP endpoints, and activating hooks requires not just stopping and starting but also deleting the .supabase temporary folder to clear cached configuration. [GitHub](https://github.com/orgs/supabase/discussions/22600)[Stack Overflow](https://stackoverflow.com/questions/78917218/supabase-local-function-on-jwt-creation) Many developers report spending hours troubleshooting hooks that simply needed a clean restart. [Stack Overflow](https://stackoverflow.com/questions/78917218/supabase-local-function-on-jwt-creation)

## Request header handling and common misconfigurations

Authorization header handling differs fundamentally between production's HTTPS environment with secure cookies and local development's HTTP environment requiring secure: false attributes. [Supabase](https://supabase.com/docs/guides/auth/server-side/advanced-guide) The critical distinction developers must internalize involves two separate header systems: the **apikey header** carries project-level keys (anon/publishable/service_role) while the **Authorization header** carries user JWT tokens as "Bearer \u003ctoken\u003e". These serve different purposes and confusion between them causes authentication failures.

**Server-side validation must always use getUser() rather than getSession()**. This represents the most important security rule for Supabase authentication. The getSession() method reads from local storage or cookies without validation, making it vulnerable to token spoofing. In contrast, getUser() sends a request to the Supabase Auth server to revalidate the JWT token on every call. [Supabase](https://supabase.com/docs/guides/auth/server-side/nextjs)[Supabase](https://supabase.com/docs/reference/javascript/v1/auth-setauth) Server Components, API routes, and middleware must exclusively use getUser() to ensure authentic user verification. [supabase](https://supabase.com/docs/guides/auth/server-side/nextjs)[Supabase](https://supabase.com/docs/guides/auth/server-side/nextjs) Client-side code can use getSession() for UI updates, but any server operation should treat getSession() data as untrusted. [GitHub](https://github.com/orgs/supabase/discussions/26791)

Cookie configuration requires environment-aware settings. Local development over HTTP cannot use secure: true, which blocks cookie transmission over non-HTTPS connections. The sameSite attribute should default to "lax" for most applications, balancing security against usability. [Supabase](https://supabase.com/docs/guides/auth/server-side/advanced-guide) Setting sameSite: "strict" prevents many legitimate cross-site navigations, while sameSite: "none" requires secure: true and only works over HTTPS. [Supabase +2](https://supabase.com/docs/guides/auth/server-side/advanced-guide) SvelteKit specifically requires explicit path: "/" parameters in cookie set operations due to framework cookie handling behaviors—without this, cookies fail to propagate across routes. [Supabase](https://supabase.com/docs/guides/auth/server-side/sveltekit)

Supabase does not use httpOnly cookies by default, contrary to common assumptions. This design choice allows the browser-based JavaScript client to access refresh tokens for session maintenance. Implementing httpOnly cookies requires server-only authentication architectures where no client-side Supabase calls occur, necessitating custom middleware to handle all auth operations and manually set httpOnly cookies from validated sessions. [GitHub](https://github.com/orgs/supabase/discussions/12303)[github](https://github.com/orgs/supabase/discussions/12303)

JWT token verification in local development uses a static secret defined in config.toml ("super-secret-jwt-token-with-at-least-32-characters-long" by default), different from production's rotatable keys. [GitHub +3](https://github.com/supabase/auth) Edge Functions can disable JWT verification using the --no-verify-jwt flag for local testing, though this creates security risks. [Supabase](https://supabase.com/docs/guides/functions/development-tips)[Supabase](https://supabase.com/docs/guides/functions/function-configuration) The new publishable key format (sb_publishable_xxx) introduced in 2024 differs from legacy JWT-based anon keys and requires the no-verify-jwt flag when calling Edge Functions locally. [Supabase](https://supabase.com/docs/guides/auth/quickstarts/nextjs)[Supabase](https://supabase.com/docs/guides/api/api-keys)

**CORS headers require manual handling in Edge Functions**, a source of persistent confusion since Supabase REST API endpoints include CORS headers automatically. Edge Functions must explicitly handle OPTIONS preflight requests as the very first operation in the function, before any other logic executes. The pattern involves checking request method for "OPTIONS" and immediately returning an "ok" response with appropriate CORS headers. [Supabase +3](https://supabase.com/docs/guides/functions/cors) Failures to place this check first cause JSON parsing errors and 400 Bad Request responses. [Stack Overflow](https://stackoverflow.com/questions/78588513/supabase-edge-functions-cors-issue)

Framework-specific header handling creates integration challenges. Next.js middleware must set cookies on both the request object (for downstream handlers) and the response object (for the browser). [Supabase](https://supabase.com/docs/guides/getting-started/tutorials/with-nextjs) Server Components cannot modify cookies directly, requiring Server Actions or Route Handlers for any cookie mutations. [supabase](https://supabase.com/docs/guides/auth/server-side/nextjs)[Supabase](https://supabase.com/docs/guides/auth/server-side/nextjs) The transition to async cookies() in Next.js 15 introduces breaking changes where code must await cookies() calls that were previously synchronous.

Header forwarding between Server Components and Route Handlers loses auth context unless explicitly preserved. When Server Components make fetch requests to API routes, the default behavior strips authentication headers. The solution requires importing the headers() function from next/headers and forwarding all headers including cookies to maintain auth context across the request chain. [Stack Overflow](https://stackoverflow.com/questions/75445386/supabase-auth-uid-user-id-equals-false)

Content-Type headers must explicitly include "application/json" in Edge Function responses, as some clients fail without proper content type declarations. Edge Functions also rewrite HTML responses to text/plain since they don't support HTML content type serving. [Supabase](https://supabase.com/docs/guides/functions/development-tips) This affects developers attempting to return formatted HTML from functions.

## Production-working environments in local development

Establishing production-equivalent local auth environments requires systematic configuration across multiple components. The foundation involves installing Docker (Desktop, OrbStack, Rancher Desktop, or Podman), installing Supabase CLI via npm, and initializing projects with supabase init. [Supabase](https://supabase.com/docs/guides/local-development)[supabase](https://supabase.com/docs/guides/local-development) Running supabase start launches the complete stack, exposing services that developers access at specific URLs: the local dashboard at [http://localhost:54323](http://localhost:54323) provides visual management, the API at [http://localhost:54321](http://localhost:54321) serves application requests, and the database listens on localhost:54322 for direct connections. [MakerKit +4](https://makerkit.dev/docs/next-supabase/running-the-application)

**Config.toml represents the source of truth for local configuration**, replicating dashboard settings that cloud users manage through UIs. OAuth provider setup demonstrates the required explicitness. Google OAuth configuration needs the provider enabled with client_id and secret loaded via env() functions, critically including redirect_uri explicitly set to "[http://localhost:54321/auth/v1/callback](http://localhost:54321/auth/v1/callback)". [Medium +4](https://medium.com/@lior_amsalem/config-supabase-localhost-auth-57a3af2ce6e9) The additional_redirect_urls array must include frontend URLs like "[http://localhost:3000](http://localhost:3000)" to allow proper post-authentication redirects. [medium +4](https://medium.com/@olliedoesdev/nextjs-supabase-google-oauth-on-localhost-0fe8b6341785) This configuration pattern, confirmed across multiple 2024 sources including Alberto Sadde's blog and Medium articles, represents the battle-tested approach.

Environment variable management follows a specific file structure. Projects should maintain a .env file at the root (git-ignored) containing secrets like GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, GITHUB_CLIENT_ID, and GITHUB_SECRET. The env() function in config.toml references these variables, [Supabase](https://supabase.com/docs/guides/local-development/managing-config)[supabase](https://supabase.com/docs/guides/local-development/managing-config) and critically, Windows users must use the env-cmd package to load environment variables, running commands like "npx env-cmd npx supabase start". [Code](https://code.build/p/local-supabase-auth-setup-nEH0UE)[code](https://code.build/p/local-supabase-auth-setup-nEH0UE) Linux and Mac users can source the file directly or use similar tooling. The .env.example file should be committed to provide team members with a template showing required variables without exposing actual secrets. [supabase](https://supabase.com/docs/guides/local-development/managing-config)

Database seeding for auth users requires populating both auth.users and auth.identities tables. Direct SQL seeding uses BCrypt password hashing via the crypt() function with gen_salt('bf'), defaulting to a consistent password like "password123" for test accounts. The pattern involves inserting users with proper UUIDs, encrypted passwords, and email_confirmed_at timestamps, then creating corresponding identity records linking users to auth providers. [Stack Overflow](https://stackoverflow.com/questions/76059457/supabase-local-development-seed-users-table)[supabase-sql](https://sql-examples.vercel.app/seed-unlimited-users) API-based seeding using supabase.auth.admin.createUser() offers a cleaner approach for complex scenarios, with Supabase handling encryption and identity creation automatically. [GitHub](https://github.com/orgs/supabase/discussions/35391)[Supabase](https://supabase.com/docs/guides/local-development/testing/overview) Trigger-based auto-population provides elegant solutions where new auth.users records automatically create corresponding public.users entries through database triggers. [Answer Overflow](https://www.answeroverflow.com/m/1326165453910970408)

**Migration synchronization from production to local** follows the sequence of supabase link to connect projects, supabase db pull to retrieve production schema, and supabase db reset to apply locally. This workflow captures production state in migration files that become the source of truth. [Supabase +2](https://supabase.com/docs/guides/local-development/overview) The --schema flag allows pulling specific schemas like auth and storage, though empty migrations directories cause the flag to be ignored. [Stack Overflow +5](https://stackoverflow.com/questions/75572348/how-to-pull-data-from-my-production-supabase-database-into-my-local-supabase-dat) Teams moving from cloud-only to local development should establish this link early, capturing all existing schema as the baseline migration.

Testing authentication flows locally leverages Inbucket for email capture. All confirmation emails, password resets, and auth emails appear in the Inbucket interface at [http://localhost:54324](http://localhost:54324) rather than sending to real addresses. [Vercel](https://docs-git-docs-add-next-js-server-component-docs-supabase.vercel.app/docs/guides/cli/local-development)[Vercel](https://docs-121fjb9m0-supabase.vercel.app/docs/guides/cli/config) Developers click confirmation links directly from Inbucket, testing complete email flows without external dependencies. [MakerKit +3](https://makerkit.dev/docs/next-supabase/running-the-application) OAuth testing requires adding both [http://localhost:54321/auth/v1/callback](http://localhost:54321/auth/v1/callback) and [http://127.0.0.1:54321/auth/v1/callback](http://127.0.0.1:54321/auth/v1/callback) to OAuth provider configurations, as some providers treat these as distinct origins. [medium](https://medium.com/@olliedoesdev/nextjs-supabase-google-oauth-on-localhost-0fe8b6341785)

The callback handler pattern for OAuth follows a specific structure. Next.js implementations create an auth/callback/route.ts file that extracts the code parameter from URL search params, calls supabase.auth.exchangeCodeForSession(code) to establish the session, and redirects to the appropriate page. [Supabase +2](https://supabase.com/docs/guides/auth/social-login/auth-github) This code exchange step represents a critical security improvement over older implicit flow patterns, preventing token exposure in URL fragments. [Supabase](https://supabase.com/docs/guides/auth/server-side/nextjs)

Production parity requires ongoing synchronization discipline. The pattern of supabase db pull followed by supabase db reset after production schema changes keeps local environments aligned. Pushing local changes to production follows the inverse pattern with supabase db push, deploying all pending migrations. [Stack Overflow +3](https://stackoverflow.com/questions/75572348/how-to-pull-data-from-my-production-supabase-database-into-my-local-supabase-dat) Configuration changes via supabase config push sync settings from config.toml to remote projects, enabling infrastructure-as-code practices.

## Vercel integration challenges and solutions

Vercel CLI and Supabase local development coexist but require careful environment variable management. Developers run supabase start in one terminal and vercel dev in another, with both services operating simultaneously. The integration point involves .env.local files containing local Supabase credentials that Next.js automatically prioritizes over other environment files during local development. The vercel env pull command retrieves deployed environment variables, which developers should rename to .env.local to prevent Git tracking while maintaining production configuration references. [Vercel](https://zone-www-dot-ge97hnogn-supabase.vercel.app/docs/guides/integrations/vercel)

**Automatic environment variable synchronization** through Vercel Marketplace integration represents the ideal setup for new projects. When creating Supabase projects through Vercel's marketplace, both platforms automatically sync critical variables including POSTGRES_URL, SUPABASE_URL, SUPABASE_ANON_KEY (or new SUPABASE_PUBLISHABLE_KEY), SUPABASE_SERVICE_ROLE_KEY, and framework-specific NEXT_PUBLIC_ prefixed versions. [Vercel](https://vercel.com/marketplace/supabase)[Vercel](https://vercel.com/templates/next.js/supabase) This sync occurs across Production, Preview, and Development environments, though timing issues sometimes require manual redeployment. [supabase](https://supabase.com/docs/guides/integrations/vercel-marketplace)

The January 2024 IPv4/IPv6 migration created a critical breaking change. Vercel doesn't support IPv6, requiring Supabase's transition from pgBouncer to Supavisor for connection pooling. Projects deployed before January 27, 2024 must redeploy for updated environment variables to take effect. [Supabase](https://supabase.com/partners/integrations/vercel) This affects connection strings and requires teams to verify their POSTGRES_URL variables reference the new pooler architecture.

**Edge Functions and Serverless Functions represent fundamentally incompatible runtimes**. Supabase Edge Functions run on Deno while Vercel Serverless Functions run on Node.js. Teams cannot deploy Supabase Edge Functions to Vercel's platform. The recommended architecture deploys Edge Functions separately to Supabase's platform via supabase functions deploy while deploying Next.js applications to Vercel. [GitHub](https://github.com/orgs/supabase/discussions/22470) For logic that must run on Vercel, teams should implement API routes in Next.js rather than attempting to bridge the runtime gap. The tsconfig.json exclude array should include "supabase" to prevent Deno code from interfering with TypeScript compilation.

Webhook and callback URL configuration across environments requires dynamic URL helpers. Production uses [https://myapp.com](https://myapp.com), preview deployments use [https://feature-branch-user.vercel.app](https://feature-branch-user.vercel.app) patterns, and local development uses [http://localhost:3000](http://localhost:3000). Wildcard redirect URL patterns in Supabase dashboard handle this variation, using patterns like "https://*-\u003cteam-slug\u003e.vercel.app/**" to match all preview deployments. The dynamic getURL() helper function checks NEXT_PUBLIC_SITE_URL, NEXT_PUBLIC_VERCEL_URL, and NEXT_PUBLIC_VERCEL_BRANCH_URL in priority order, falling back to localhost for development. This helper ensures OAuth redirects and email confirmation links work across all deployment types.

Local webhook development requires host.docker.internal instead of localhost URLs. Supabase services run inside Docker containers where "localhost" refers to the container itself rather than the host machine. Database webhooks and Edge Function callbacks must use "[http://host.docker.internal:3000/api/webhook](http://host.docker.internal:3000/api/webhook)" patterns to reach services on the developer's machine. [GitHub](https://github.com/orgs/supabase/discussions/12813)

**Middleware represents the critical integration point** for auth token management. Next.js middleware running on Vercel Edge Runtime must refresh tokens by calling supabase.auth.getUser(), setting cookies on both the request object (for downstream Server Components) and the response object (for browser updates). [Supabase](https://supabase.com/docs/guides/auth/server-side/nextjs) The pattern requires createServerClient from @supabase/ssr with custom cookie handlers implementing getAll and setAll methods. [Supabase](https://supabase.com/docs/guides/auth/server-side/nextjs)[medium](https://the-shubham.medium.com/next-js-supabase-cookie-based-auth-workflow-the-best-auth-solution-2025-guide-f6738b4673c1) This middleware prevents multiple components from attempting simultaneous token refreshes and ensures all requests have fresh tokens. [supabase](https://supabase.com/docs/guides/auth/server-side/nextjs)

Preview deployment environment variables occasionally fail to sync due to race conditions in the integration. When Vercel creates preview deployments before Supabase completes preview branch setup, deployments use production database credentials instead of preview branch credentials. [GitHub](https://github.com/orgs/supabase/discussions/32596) The workaround involves manual environment variable configuration in Vercel's dashboard, setting Preview-specific variables to preview branch values from Supabase dashboard. [GitHub](https://github.com/orgs/supabase/discussions/32596) Alternatively, teams should avoid setting NEXT_PUBLIC_SITE_URL for Preview environment, allowing Vercel's automatic NEXT_PUBLIC_VERCEL_URL to provide dynamic URLs. [GitHub](https://github.com/orgs/supabase/discussions/32596)

Supabase Branching integration with Vercel preview deployments (Pro plan feature) automatically creates preview database branches when PRs are opened. Each preview branch gets unique API credentials that sync to Vercel's preview environment variables. [GitHub +3](https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/deployment/branching.mdx) The workflow involves opening a PR, Vercel creating preview deployment, Supabase creating preview branch, environment variables syncing, and Vercel redeploying with correct credentials. [Supabase](https://supabase.com/docs/guides/deployment/branching/integrations) Preview branches start data-less by default, using seed.sql files for initial data population, providing secure testing environments isolated from production data. [Supabase +2](https://supabase.com/docs/guides/deployment/branching)

## RLS violations between environments

Row Level Security policy enforcement differences between local and production environments create subtle but critical failures. The auth.uid() function returns NULL or empty strings unexpectedly in local development when switching between database roles within the same connection. This bug, documented in GitHub issue #4244, occurs after PostgREST 9 upgrades where current_setting() returns empty strings instead of NULL during role switches, causing UUID casting failures in RLS policies. [github](https://github.com/supabase/supabase/issues/4244)[GitHub](https://github.com/supabase/supabase/issues/4244) The fix requires replacing auth.uid() with a version wrapped in NULLIF that explicitly handles empty string cases:

sql

```sql
CREATE OR REPLACE FUNCTION auth.uid()
RETURNS uuid
LANGUAGE sql STABLE
AS $$
  SELECT NULLIF(
    COALESCE(
      current_setting('request.jwt.claim.sub', true),
      (current_setting('request.jwt.claims', true)::jsonb ->> 'sub')
    ),
    ''
  )::uuid
$$;
```

[GitHub](https://github.com/supabase/supabase/issues/4244)

**Service role key clients unexpectedly encountering RLS enforcement** stems from three common patterns. First, using @supabase/ssr clients initialized with service_role keys fails because SSR clients are designed to share user sessions from cookies, with user sessions overriding the service key in Authorization headers. Second, calling auth functions like signInWithPassword on a service_role client sets user tokens that override the service role for subsequent queries. Third, manually setting Authorization headers in client options overrides the service_role key provided in the constructor. [supabase +2](https://supabase.com/docs/guides/troubleshooting/why-is-my-service-role-key-client-getting-rls-errors-or-not-returning-data-7_1K9z) The solution requires maintaining completely separate client instances: admin clients using direct supabase-js imports with service role keys, and user clients using SSR implementations with anon keys. [GitHub](https://github.com/orgs/supabase/discussions/30739)[supabase](https://supabase.com/docs/guides/troubleshooting/why-is-my-service-role-key-client-getting-rls-errors-or-not-returning-data-7_1K9z)

Custom JWT claims work in production but return empty in local development without proper configuration. Custom Access Token Hooks require config.toml entries with enabled: true and uri: "pg-functions://postgres/public/custom_access_token_hook" patterns. [GitHub](https://github.com/orgs/supabase/discussions/22600) After adding hook configuration, developers must stop Supabase, delete the .supabase temporary folder, and start again—a database reset alone doesn't activate hooks. [Stack Overflow +2](https://stackoverflow.com/questions/78917218/supabase-local-function-on-jwt-creation) The hook function needs explicit grants: GRANT USAGE ON SCHEMA public TO supabase_auth_admin and GRANT EXECUTE ON FUNCTION to the auth admin role, with corresponding revocations from public, authenticated, and anon roles for security. [Supabase](https://supabase.com/docs/guides/database/postgres/custom-claims-and-role-based-access-control-rbac)

**Auth context propagation in Next.js Server Components** fails when developers import browser clients instead of server clients due to VSCode auto-import behavior. Server Components must use createClient from @/utils/supabase/server which wraps createServerClient with cookie handling. [Stack Overflow](https://stackoverflow.com/questions/78442623/nextjs-supabase-ssr-row-level-security) Route Handler requests from Server Components lose auth context unless headers are explicitly forwarded using headers() from next/headers. [Stack Overflow](https://stackoverflow.com/questions/75445386/supabase-auth-uid-user-id-equals-false) Server Actions require getUser() validation at the start of each action, never trusting getSession() data that could be manipulated by clients.

RLS policy synchronization from production to local requires schema-specific pulling. Storage bucket policies don't sync through standard supabase db pull commands, requiring explicit --schema storage flags. Auth schema policies similarly need --schema auth flags. [Stack Overflow +5](https://stackoverflow.com/questions/75572348/how-to-pull-data-from-my-production-supabase-database-into-my-local-supabase-dat) CLI versions create additional complications, with version 1.113.2 exhibiting a bug where RLS policies become invisible in local Studio despite being applied to the database. Downgrading to version 1.110.3 restores policy visibility. [Stack Overflow](https://stackoverflow.com/questions/77534982/supabase-cli-local-development-problems-with-rls-and-enabling-realtime)

Testing RLS policies locally requires explicit role and JWT claim configuration. Database testing with pgTAP extensions enables automated policy verification through SQL test files setting local roles and request.jwt.claim.sub variables to simulate authenticated users. The pattern involves transactions that set role to authenticated, configure JWT claims, execute test queries, and verify results before rolling back. [supabase](https://supabase.com/docs/guides/local-development/testing/overview)[Supabase](https://supabase.com/docs/guides/local-development/testing/overview) Application-level testing requires unique UUIDs per test run to avoid conflicts between parallel test executions, with beforeAll hooks using admin clients to seed test users via supabase.auth.admin.createUser(). [supabase](https://supabase.com/docs/guides/local-development/testing/overview)[Supabase](https://supabase.com/docs/guides/local-development/testing/overview)

Type mismatches between auth.uid() and user_id columns create subtle RLS failures. Standard implementations use UUID columns matching auth.uid() returns, but external auth providers using KSUID or other string identifiers require casting both sides to text. [GitHub](https://github.com/orgs/supabase/discussions/4954) The auth.user_id() helper function variant returns text instead of UUID for these scenarios.

**UPDATE operations failing despite SELECT succeeding** stems from incomplete policy definitions. UPDATE policies require both USING clauses (for determining visible rows) and WITH CHECK clauses (for validating updated values). Many developers only add USING clauses, causing silent failures on updates that appear to succeed client-side but don't persist. [Stack Overflow](https://stackoverflow.com/questions/73264248/update-rls-in-supabase-seems-broken) Complete policy implementations separate SELECT, INSERT, UPDATE, and DELETE policies with appropriate USING and WITH CHECK clauses for each operation type. [Supabase](https://supabase.com/docs/guides/troubleshooting/rls-simplified-BJTcS8)

Debugging local RLS issues requires systematic approaches. The EXPLAIN extension shows query plans including RLS policy evaluation costs. Manual role switching in SQL editor transactions allows testing policies from different user perspectives without application code. Service role client comparisons isolate whether data absence stems from RLS policies or missing data. JWT claim logging through session token decoding reveals claim content for verifying custom claims propagate correctly.

## Server-side auth context and change management

Server-side authentication context handling differs fundamentally between local development's localStorage patterns and production's cookie-based SSR requirements. Local development traditionally stores tokens in browser localStorage with client-side-only access, while production SSR applications must use secure cookies accessible to both client and server. The PKCE flow requirement for SSR differs from simpler implicit flows, necessitating cookie-based session management where tokens pass between client and server on each request. [Supabase](https://supabase.com/docs/guides/auth/server-side/advanced-guide)[supabase](https://supabase.com/docs/guides/auth/server-side/advanced-guide)

**Three distinct Supabase client types serve different purposes in SSR frameworks**. Browser clients from createBrowserClient handle client-side operations in components and browser-only code. Server clients from createServerClient with cookie handling enable Server Components, API routes, and server functions to access auth context. Middleware clients implement specialized cookie setters that update both request cookies (for downstream handlers) and response cookies (for browser updates). [Supabase](https://supabase.com/docs/guides/auth/server-side/nextjs)[Supabase](https://supabase.com/docs/guides/auth/server-side/creating-a-client) Confusing these client types or using the wrong client in the wrong context causes auth failures that manifest as NULL user IDs or missing session data. [supabase](https://supabase.com/docs/guides/auth/server-side/nextjs)

Next.js route prefetching creates race conditions where Link components trigger server-side requests before browsers process authentication tokens from URL fragments. Server requests arrive without cookies, rendering and caching unauthenticated content. The workaround involves redirecting users to specific non-prefetched pages immediately after authentication completes, allowing the browser to process tokens before navigation occurs. [Supabase +2](https://supabase.com/docs/guides/auth/server-side/advanced-guide) Middleware token refresh prevents multiple components from attempting simultaneous refreshes by centralizing refresh logic and distributing refreshed tokens to all request handlers. [Supabase](https://supabase.com/docs/guides/auth/server-side/advanced-guide)

Cookie security attributes must adapt to environments. Local development over HTTP requires secure: false to allow cookie transmission, while production HTTPS mandates secure: true. The sameSite: "lax" setting balances security and usability for most applications, preventing CSRF attacks while allowing normal navigation. [Supabase](https://supabase.com/docs/guides/auth/server-side/advanced-guide) Domain attributes should be omitted in local development but may be necessary for production subdomain scenarios.

**Git workflow patterns for database changes** follow feature branch models with develop serving as staging integration and main representing production. Developers create feature branches for schema changes, generate migration files via supabase migration new or supabase db diff, test locally with supabase db reset, and open PRs that trigger CI tests and preview deployments. [Supabase](https://supabase.com/docs/guides/deployment/managing-environments)[supabase](https://supabase.com/docs/guides/cli/managing-environments) Staging validation on develop branch precedes production deployment via main branch merges. [Supabase](https://supabase.com/docs/guides/deployment/managing-environments)

Migration file management requires timestamp-based sequencing ensuring chronological application order. The supabase migration new command creates appropriately timestamped files. Schema changes made through dashboard or manual SQL require supabase db diff -f feature_name to capture changes as migration files. [Supabase +3](https://supabase.com/docs/guides/deployment/managing-environments) Merge conflicts necessitate renaming migrations with newer timestamps and testing the complete migration sequence locally before pushing. [Supabase](https://supabase.com/docs/guides/deployment/managing-environments)

**CI/CD pipelines automate testing and deployment** through GitHub Actions workflows. Test workflows run on pull requests, starting local Supabase instances via supabase db start, verifying generated types remain current, and executing database tests through supabase test db. [Supabase](https://supabase.com/docs/guides/deployment/managing-environments) Release workflows trigger on develop and main branch pushes, linking projects via supabase link, pushing migrations via supabase db push, and deploying Edge Functions via supabase functions deploy. [Supabase +5](https://supabase.com/docs/guides/deployment/managing-environments) Environment-specific configurations deploy to staging for develop and production for main. [Supabase](https://supabase.com/docs/guides/deployment/managing-environments)

Database branching enables preview environments with isolated data. Preview branches created automatically per PR provide ephemeral testing environments deleted when PRs close. Persistent branches like staging serve as long-lived environments for extended testing. [GitHub +2](https://github.com/supabase/supabase/blob/master/apps/docs/content/guides/deployment/branching.mdx) Branch deployment workflows clone repositories, pull migrations from main projects, wait for service health, apply configurations from config.toml, run migrations, execute seed files, and deploy changed functions. [Supabase](https://supabase.com/docs/guides/deployment/branching)[Supabase](https://supabase.com/docs/guides/deployment/branching/integrations) Failures at any step skip dependent operations, with clear status reporting. [Supabase](https://supabase.com/docs/guides/deployment/branching)[supabase](https://supabase.com/docs/guides/deployment/branching)

**Rollback strategies emphasize forward-only migrations** since automated rollbacks risk data loss. The CLI intentionally omits migrate down functionality. Recommended approaches write new migrations that undo problematic changes rather than attempting to reverse migrations. Local development allows supabase db reset --version targeting specific migration timestamps. [supabase +2](https://supabase.com/docs/guides/cli/managing-environments) Manual rollback scripts use supabase migration repair to mark migrations as reverted before executing undo SQL. Production environments benefit from PITR (Point-in-Time Recovery) enabling restoration to specific timestamps with minimal performance impact. [Supabase](https://supabase.com/docs/guides/deployment/maturity-model)[Restack](https://www.restack.io/docs/supabase-knowledge-supabase-best-practices)

Configuration as code through config.toml provides version-controlled infrastructure definitions. Complete configurations specify project IDs, API ports and schemas, database settings, seed file paths, auth configurations including external providers, storage bucket definitions with size limits and MIME types, and remote branch configurations for staging deployments. The supabase config push command deploys configuration to remote projects.

**Team collaboration practices** include access control limiting production access to qualified members, migration review processes verifying security and performance, [Supabase +2](https://supabase.com/docs/guides/deployment/maturity-model) handling merge conflicts through migration renaming with updated timestamps, and production checklists covering security (RLS policies enabled, keys secured), migrations (version controlled, tested in staging, backups configured), CI/CD (workflows configured, secrets stored, approvals required), monitoring (performance tracking, error alerts, logging), and team processes (no direct dashboard changes, required code reviews, documented procedures). [Vercel +2](https://docs-rog1zs1kv-supabase.vercel.app/docs/guides/cli/managing-environments)

Common pitfalls include tables created via dashboard owned by supabase_admin rather than postgres, preventing CLI migration alterations until ownership changes via ALTER TABLE OWNER TO postgres. [Supabase +2](https://supabase.com/docs/guides/deployment/managing-environments) Preview branch environment variables fail to sync when projects are created through Vercel marketplace rather than Supabase dashboard. [GitHub](https://github.com/orgs/supabase/discussions/32596) Migration synchronization issues require checking supabase migration list status and using db pull or db push to align local and remote states.

## Proven patterns and practical implementations

The complete working implementation for Next.js App Router applications establishes three client utilities. The browser client in lib/supabase/client.ts uses createBrowserClient with public URL and anon key environment variables. The server client in lib/supabase/server.ts awaits cookies(), creates a server client with getAll and setAll cookie handlers, and wraps errors from Server Component cookie setting attempts. [Supabase](https://supabase.com/docs/guides/auth/server-side/nextjs)[Supabase](https://supabase.com/docs/guides/getting-started/quickstarts/nextjs) The middleware utility in lib/supabase/middleware.ts creates a server client with specialized cookie handlers that set on both request and response objects, calls getUser() to refresh tokens, and returns the updated response. [supabase +4](https://supabase.com/docs/guides/auth/server-side/nextjs)

Middleware configuration requires a matcher excluding static assets, Next.js internals, and common media file extensions to prevent unnecessary auth checks on every asset request. [Supabase](https://supabase.com/docs/guides/auth/server-side/nextjs) The pattern matches all routes except those starting with _next/static, _next/image, favicon.ico, or common image extensions. [supabase](https://supabase.com/docs/guides/auth/server-side/nextjs)[Supabase](https://supabase.com/docs/guides/auth/server-side/nextjs)

**Environment-specific configurations** use conditional secure attributes, with process.env.NODE_ENV === 'production' determining HTTPS requirements. Development environments omit domain attributes while production may need domain: '.example.com' for subdomain cookie sharing. The maxAge or expires settings should align with JWT expiry times from auth configuration.

Deployment to Vercel follows a sequence of vercel link connecting projects, vercel env add for environment-specific variables (production, preview, development), and vercel --prod for production deployments. Environment variables must include framework-prefixed public variables for client access and unprefixed variables for server-only secrets. [Bootstrapped](https://bootstrapped.app/guide/how-to-set-up-continuous-deployment-with-supabase-and-vercel)

**Protected Edge Function patterns** implement CORS preflight handling as the first operation, extract Authorization headers with validation, create authenticated Supabase clients by forwarding authorization headers, verify users via getUser() with the extracted token, and execute protected logic with verified user context. [Supabase](https://supabase.com/docs/guides/functions/auth)[Permit.io](https://www.permit.io/blog/supabase-authentication-and-authorization-in-nextjs-implementation-guide) Error handling returns appropriate status codes (401 for missing auth, 400 for other errors) with JSON error messages and correct content types. [Supabase](https://supabase.com/docs/guides/functions/auth)

Service role operations use completely separate client instances. Admin operations instantiate clients via createClient from @supabase/supabase-js with service role keys and no cookie configurations. User operations use SSR clients with anon keys and cookie handling. [GitHub](https://github.com/orgs/supabase/discussions/30739)[supabase](https://supabase.com/docs/guides/troubleshooting/why-is-my-service-role-key-client-getting-rls-errors-or-not-returning-data-7_1K9z) Mixing these contexts causes RLS bypass failures.

Database testing with pgTAP creates test files in supabase/tests/ that begin transactions, load the pgtap extension, declare test counts via SELECT plan(), insert test users into auth.users and auth.identities, set local roles and JWT claims simulating authenticated sessions, execute test queries with results_eq and lives_ok assertions, complete via SELECT * FROM finish(), and rollback to maintain database cleanliness. Running supabase test db executes all test files. [supabase](https://supabase.com/docs/guides/local-development/testing/overview)[Supabase](https://supabase.com/docs/guides/local-development/testing/overview)

**Complete OAuth implementation** involves configuring providers in config.toml with enabled: true, client_id from environment variables, secrets from environment variables, and critical redirect_uri pointing to "[http://localhost:54321/auth/v1/callback](http://localhost:54321/auth/v1/callback)" for local development. [Alberto Sadde +4](https://www.albertosadde.com/blog/local-auth-with-subapase/) OAuth provider dashboards must include matching redirect URIs for both localhost and 127.0.0.1. [Stack Overflow +5](https://stackoverflow.com/questions/75779769/can-i-fully-login-with-supabase-on-local-and-google-oauth-on-my-flutter-app) Client-side sign-in calls supabase.auth.signInWithOAuth with provider specifications and redirectTo options using dynamic URL helpers. Callback route handlers extract code parameters, call exchangeCodeForSession, and redirect to appropriate destinations based on next parameters or default routes. [Stack Overflow +2](https://stackoverflow.com/questions/78594750/supabase-oauth-redirect-not-working-for-localhost)

Production migration workflows follow predictable patterns. Local schema changes generate migrations via supabase db diff. Local testing via supabase db reset validates migration application. Git commits and pushes trigger CI workflows. PR creation starts preview deployments with preview branch databases. Staging merges deploy to develop branches with staging databases. Production merges deploy to main branches with production databases. [Medium +4](https://medium.com/@rmizad031/getting-started-with-supabase-easy-local-environment-setup-for-beginners-32d3a550ff71) Monitoring and smoke testing verify successful deployments.

RLS policy performance optimization adds indexes on columns used in policy conditions, particularly user_id columns frequently compared against auth.uid(). Wrapping auth.uid() in SELECT subqueries enables PostgreSQL query planner initPlan caching. Avoiding subquery joins on the protected table itself prevents nested loop performance problems. Security definer functions bypass RLS on intermediate tables while maintaining overall security boundaries. [Supabase](https://supabase.com/docs/guides/troubleshooting/rls-performance-and-best-practices-Z5Jjwv)

## Critical implementation checklist

Development environment setup requires Docker running, Supabase CLI installed via npm, supabase init execute [Supabase](https://supabase.com/docs/guides/local-development)d in project root, and supabase start launching local services. Verify access to local dashboard at port 54323, API at port 54321, and database at port 54322. [Supabase](https://supabase.com/docs/guides/local-development)

Config.toml must enable auth, specify correct site_url matching frontend, include additional_redirect_urls for all callback destinations, configure external providers with enabled, client_id from env(), secret from env(), and explicit redirect_uri for local endpoints. [GitHub](https://github.com/supabase/supabase/issues/28008) Save secrets in .env files (gitignored) and provide .env.example templates for teams. [supabase](https://supabase.com/docs/guides/local-development/managing-config)

**Client implementation checklist** creates browser clients from @supabase/ssr for client components, server clients with cookie handling for Server Components and API routes, middleware clients with request and response cookie setting for token refresh, and separate admin clients using direct supabase-js imports for service role operations. [Supabase](https://supabase.com/docs/guides/auth/server-side/nextjs) Never mix client types or use browser clients in server contexts.

Server-side validation always calls getUser() for auth verification, never trusts get [Supabase](https://supabase.com/docs/guides/auth/server-side/nextjs)Session() data without revalidation, [Supabase](https://supabase.com/docs/guides/auth/server-side/nextjs)[Supabase](https://supabase.com/docs/reference/javascript/v1/auth-setauth) forwards headers including cookies for Server Component fetch requests, wraps Server Actions with getUser() validation at start, and handles errors by redirecting to login pages.

Middleware configuration places middleware.ts in project root or src directory, uses matcher excluding static assets and Next.js internals, calls updateSession utility that refreshes tokens via getUser(), sets cookies on both request and response, and returns response for continued request processing.

Testing strategy includes pgTAP database tests in supabase/tests/, application tests using unique UUIDs per test run, Playwright or Cypress for end-to-end flows, separate test users seeded via admin API, and complete transaction isolation to prevent test interference.

**Environment variable organization** maintains .env.local for local development (gitignored), .env.example as committed templates, separate production, preview, and development configurations in Vercel dashboard, framework-specific prefixes for client-accessible variables, and verification that all required variables exist in all environments.

Migration discipline requires all schema changes captured as migration files, local testing via db reset before committing, version control for all migration files, code review for SQL security and performance, staging validation before production deployment, and documented rollback procedures for emergency scenarios. [Supabase](https://supabase.com/docs/guides/deployment/database-migrations)

Security validation confirms RLS policies enabled on all user-facing tables, service role keys never [Supabase](https://supabase.com/docs/guides/deployment/going-into-prod) exposed to frontend code, getUser() used exclusively in server code for validation, custom hooks configured with proper grants and revocations, JWT secrets rotated regularly, and HTTPS enforced in production with appropriate cookie attributes.

Production deployment preparation includes PITR enabled for rollback capability, monitoring configured for migration failures and performance degradation, error tracking integrated to catch auth issues, documentation maintained for deployment procedures and incident response, and approval workflows requiring reviews before production changes.

**Common error resolution patterns** address "invalid input syntax for type uuid" by applying NULLIF wrapper to auth.uid(), "new row violates row-level security policy" by adding WITH CHECK clauses to policies, "Auth session missing" by verifying getUser() usage and cookie forwarding, service role RLS errors by separating admin and user clients, and "Cannot read properties of undefined" by ensuring proper server client usage.

Vercel integration requires environment variables set for all environments (production, preview, development), wildcard redirect URLs configured in Supabase dashboard matching Vercel preview patterns, middleware implementing token refresh for Edge Runtime compatibility, Edge Functions deployed separately to Supabase platform (not Vercel), tsconfig.json excluding supabase folder from compilation, and webhook URLs using host.docker.internal for local development.

This comprehensive implementation approach addresses the seven critical areas through systematic configuration, proper client separation, explicit cookie handling, complete testing coverage, and disciplined change management workflows that maintain environment parity while respecting platform-specific requirements.